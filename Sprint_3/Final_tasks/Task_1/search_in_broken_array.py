"""
-- ПРИНЦИП РАБОТЫ --
# Если честно, алгоритм очень хорошо описан в теории к спринту: "Реализация бинарного поиска с помощью рекурсии".
Поскольку масив был сдвинут, то дополнительно для использования бинарного поиска нам необходимо
провести проверку на нахождение отсортированной половины массива. Например, сравнив левый конец с медианой.
После этой проверки воспользуемся рекурсивным бинарным поиском.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
По условию сказано "... в массиве только уникальные элементы".
    - В случае right > mid мы будем рассматривать отрезок [mid; right), значит можно отбрость левую
      половину массива, проводя дальнейший поиск только в правой половине, т.е. новые границы поиска
      будут: [mid; right) и этот полуинтервал будет точно отсортирован.
    - В случае left < mid мы будем рассматривать отрезок [left; mid), значит можно отбрость правую
      половину массива, проводя дальнейший поиск только в левой половине, т.е. новые границы поиска
      будут: [left; mid) - этот полуинтервал будет также отсортирован.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
При использовании бинарного поиска мы сокращаем интервал поиска в два раза, значит временная сложность будет O(log(n)).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы храним исходный массив и используем рекурсивные вызовы. В худшем случае (см. временную сложность) мы имеем
сложность O(logN), т.к. делаем O(logN) вызовов и храним на стеке значения каждого вызова.
Такая сложность также связана с тем, что в python не поддерживается оптимизация хвостовой рекурсии.
"""

"""
-- ID успешной посылки --
56013520
"""

"""
Вернулся к первой версии реализации поиска. Спасибо большое за совет! Изначально запутался в промежутках...,
поэтому, чтобы проходило все тест-кейсы и написал те функции, которые находили границы. Но теперь разобрался с ними.
Спасибо :) !
"""


# Рассчет середины массива.
def count_mid(left, right):
    return (right + left) // 2


# Рекурсивный бинарный поиск.
def binary_search(array_, left_, right_, element_):
    # Находим середину массива.
    mid = count_mid(left_, right_)

    # Если найденная середина массива и есть искомый элемент, то сразу вернем результат.
    if array_[mid] == element_:
        return mid

    # Базовый случай рекурсии.
    if right_ - left_ <= 0:
        return -1

    # Случай, когда левая часть отсортирована.
    if array_[left_] <= array_[mid]:
        if array_[left_] <= element_ < array_[mid]:
            return binary_search(array_, left_, mid, element_)
        else:
            return binary_search(array_, mid + 1, right_, element_)

    # Случай, когда левая часть отсортирована.
    if array_[left_] > array_[mid]:
        if array_[mid] < element_ <= array_[right_]:
            return binary_search(array_, mid + 1, right_, element_)
        else:
            return binary_search(array_, left_, mid, element_)


# Финкция поиска элемента в массиве.
def broken_search(array_, element_):
    left_ = 0
    right_ = len(array_) - 1

    return binary_search(array_, left_, right_, element_)


if __name__ == '__main__':
    n = int(input())  # Длина массива.
    element = int(input())  # Элемент массива, индекс которого надо найти.
    array = list(map(int, input().strip().split()))[:n]  # Исходный массив.

    print(broken_search(array, element))
