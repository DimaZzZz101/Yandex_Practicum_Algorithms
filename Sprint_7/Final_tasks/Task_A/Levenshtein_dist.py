"""
-- ПРИНЦИП РАБОТЫ --
В данной задаче мы вычисляем матрицу расстояний Левенштейна для двух последовательностей.

За базовый случай мы берем длину последовательности.

Далее с помощью динамического программирования мы сравниваем символы на предыдущих позициях:
    - если они одинаковые: берем уже вычисленное расстояние,
    - иначе: берем min + 1

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Можно доказать Методом Математической Индукции (ММИ), что Mn - 1k - 1 < Mnk + 1.

Поскольку у нас возрастающая двумерная поверхность - при доказательстве от противного имеем Mn-1k-1 > Mnk + 1 =>
=> противоречие.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Поскольку мы обходим массив размерностью, значит временная сложность будет O(M * N),
где N - длина первой последовательности,
    M - длина второй последовательности.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В памяти мы храним и заполняем значения в двух последовательностях символов длины N, значит сложность O(N)
"""

"""
-- ID успешной посылки --
63919019
"""


def main():
    first = list(input().strip())
    second = list(input().strip())

    n = len(first)
    m = len(second)

    if m == 0 or n == 0:
        return max(n, m)

    row = [i for i in range(n + 1)]
    new_row = [j for j in range(n + 1)]

    for i in range(1, m + 1):
        new_row[0] = i
        for j in range(1, n + 1):
            if second[i - 1] == first[j - 1]:
                new_row[j] = row[j - 1]
            else:
                new_row[j] = min(new_row[j - 1], row[j], row[j - 1]) + 1
        row = new_row.copy()

    levenshtein_dist = row[-1]

    return levenshtein_dist


if __name__ == '__main__':
    print(main())
