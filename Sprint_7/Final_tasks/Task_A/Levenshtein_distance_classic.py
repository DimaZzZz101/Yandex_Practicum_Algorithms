"""
-- ПРИНЦИП РАБОТЫ --
В данной задаче мы вычисляем матрицу расстояний Левенштейна для двух последовательностей.

За базовый случай мы берем длину последовательности.

Далее с помощью динамического программирования мы сравниваем символы на предыдущих позициях:
    - если они одинаковые: берем уже вычисленное расстояние,
    - иначе: берем min + 1

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Можно доказать Методом Математической Индукции (ММИ), что Mn - 1k - 1 < Mnk + 1.

Поскольку у нас возрастающая двумерная поверхность - при доказательстве от противного имеем Mn-1k-1 > Mnk + 1 =>
=> противоречие.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Поскольку мы обходим массив размерностью N x M, значит временная сложность будет O(M * N),
где N - длина первой последовательности,
    M - длина второй последовательности.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В памяти мы храним и заполняем значения в массиве M x N, значит сложность O(M * N),
где N - длина первой,
    M - длина второй последовательности
"""

"""
-- ID успешной посылки --
63668747
"""


def main():
    first = list(input().strip())
    second = list(input().strip())

    n = len(first)
    m = len(second)

    if m == 0 or n == 0:
        return max(n, m)

    dp = [[i] + [0] * m for i in range(n + 1)]
    dp[0] = list(range(0, m + 1))

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if first[i - 1] == second[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1

    levenshtein_dist = dp[n][m]

    return levenshtein_dist


if __name__ == '__main__':
    print(main())
